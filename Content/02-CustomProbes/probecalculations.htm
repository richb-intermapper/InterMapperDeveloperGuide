<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:conditions="Primary.online,Primary.print" MadCap:check_list="Ran Smart Index" MadCap:id="Probe_Calculations" MadCap:timeEstimate="0" MadCap:priority="0" MadCap:status="In Progress" MadCap:lastBlockDepth="6" MadCap:lastHeight="850" MadCap:lastWidth="576">
    <head><title></title>
        <link rel="StyleSheet" href="../Resources/default.css" />
    </head>
    <body>
        <h1 class="L2" style="page-break-before: always;">
            <MadCap:keyword term="Matches;Include;Probe Calculations" />Probe Calculations</h1>
        <p>
            <MadCap:keyword term="Values" />
            <MadCap:keyword term="Include:SNMP MIB" />
            <MadCap:keyword term="Var" />
            <MadCap:keyword term="SNMP MIB" />
            <MadCap:keyword term="TRUE:value" />
            <MadCap:keyword term="PI:value" />
            <MadCap:keyword term="FALSE:value" />
            <MadCap:keyword term="VALUE" />InterMapper can compute values from data retrieved from devices, including 
 SNMP MIB variables, round-trip time, packet loss, availability, etc. The 
 results of these computations can be compared to thresholds to set device 
 status and indicate problems.</p>
        <h2>Expression Syntax</h2>
        <p>
            <MadCap:keyword term="Expr" />
            <MadCap:keyword term="Exp" />InterMapper's Expression Syntax has the following features:</p>
        <ul>
            <li>
                <MadCap:keyword term="Unary" />
                <MadCap:keyword term="Min" />Supports arithmetic expressions using +, -, *, /, 
 %, and unary minus. </li>
            <li>
                <MadCap:keyword term="Sub-expressions" />Supports the use of parentheses to group sub-expressions 
 for calculation first. </li>
            <li>
                <MadCap:keyword term="Double-precision" />Stores all intermediate and final results as double-precision 
 floating point numbers. </li>
            <li>
                <MadCap:keyword term="Values:FALSE" />
                <MadCap:keyword term="Values:TRUE" />Supports relational operators &lt;, &gt;, &lt;=, 
 &gt;=, =, &lt;&gt;, ==, !=. The value for TRUE is "1.0". The 
 value for FALSE is "0.0". </li>
            <li>Supports short-circuit logical operators 'and', 'or', 
 'not' as well as &amp;&amp;,||,!,. </li>
            <li>
                <MadCap:keyword term="Functions" />
                <MadCap:keyword term="FUNCTION" />
                <MadCap:keyword term="Bitwise:functions" />Supports variables and functions from a provided 
 symbol table. Variables may use $var syntax or ${var} syntax. </li>
            <li>
                <MadCap:keyword term="Functions:bitwise" />
                <MadCap:keyword term="Bitwise" />Supports built-in functions for bitwise operations, 
 rounding, and other common mathematical functions. </li>
            <li>
                <MadCap:keyword term="String" />
                <MadCap:keyword term="Matches:String" />
                <MadCap:keyword term="Perl-like" />
                <MadCap:keyword term="Concatenation" />
                <MadCap:keyword term="Str" />
                <MadCap:keyword term="Perl" />Supports embedded string comparisons and simple regular 
 expression tests. A variable in double-quotes will be treated as a string. 
 All double-quoted strings are interpolated for variables in a Perl-like 
 fashion. The use of + as the concatenation operator is supported. See below for <a href="#regexp">an example that uses Regular Expressions<MadCap:xref href="#regexp" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>.</li>
        </ul>
        <p>
            <MadCap:keyword term="Excel" />The set of capabilities are derived from C, Perl, Excel, and expr(1).</p>
        <h2>Reserved keywords</h2>
        <ul>
            <li>and </li>
            <li>or </li>
            <li>not </li>
        </ul>
        <h2>
            <MadCap:keyword term="Precedence Table" />Precedence Table (Least to Most)</h2>
        <ol>
            <li>Assignment: := </li>
            <li>
                <MadCap:keyword term="Conditional Expression" />Conditional Expression: ?: </li>
            <li>
                <MadCap:keyword term="Logical Or" />Logical Or: 'or', || </li>
            <li>
                <MadCap:keyword term="Logical And" />Logical And: 'and', &amp;&amp; </li>
            <li>
                <MadCap:keyword term="Equality Tests" />Equality Tests: ==, =, !=, </li>
            <li>
                <MadCap:keyword term="Relational Tests" />Relational Tests: &lt;, &gt;, &lt;=, &gt;=</li>
            <li>
                <MadCap:keyword term="Addition, Subtraction" />Addition, Subtraction, Concatenation: +,- </li>
            <li>
                <MadCap:keyword term="Modulo" />
                <MadCap:keyword term="Multiplication, Division" />Multiplication, Division, Modulo: *, /, % </li>
            <li>
                <MadCap:keyword term="String:Matching" />String Matching: =~, !~ </li>
            <li>Unary: -, !, 'not' </li>
        </ol>
        <h2 class="pagebreakbefore">
            <MadCap:keyword term="Built-in Numeric Functions" />Built-in Numeric Functions</h2>
        <ul>
            <li>
                <MadCap:keyword term="Abs" />abs( x ) - Absolute value of 'x'.</li>
            <li>
                <MadCap:keyword term="Integer" /><a href="#round">round<MadCap:xref href="#round" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>(x),round(x,y) - Round 'x' to nearest integer.</li>
            <li>
                <MadCap:keyword term="Trunc" />trunc( x ) - Remove all digits after the decimal 
 point; e.g. trunc( 3.987) = 3.</li>
            <li>
                <MadCap:keyword term="Values:x1" />min( x1, x2, ... , xn ) - Minimum value of x1, x2, 
 ..., xn.</li>
            <li>max( x1, x2, ... , xn ) - Maximum value of x1, x2, 
 ..., xn.</li>
            <li>
                <MadCap:keyword term="Bitand" />bitand( x, y ) - Bitwise 'and' of 'x' and 'y'.</li>
            <li>
                <MadCap:keyword term="Bitor" />bitor( x, y ) - Bitwise 'or' of 'x' and 'y'.</li>
            <li>
                <MadCap:keyword term="Bitlshift" />bitlshift( x, y ) - Bits of 'x' shifted left by 'y' 
 bits.</li>
            <li>
                <MadCap:keyword term="Bitrshift" />bitrshift( x, y ) - Bits of 'x' shifted right by 
 'y' bits.</li>
            <li>
                <MadCap:keyword term="Bitxor" />bitxor( x, y ) - Bitwise exclusive-or of 'x' and 
 'y'.</li>
            <li>sin( x ) - sine of 'x' where 'x' is in radians.</li>
            <li>
                <MadCap:keyword term="Cos" />cos( x ) - cosine of 'x' where 'x' is in radians.</li>
            <li>tan( x ) - tangent of 'x' where 'x' is in radians.</li>
            <li>
                <MadCap:keyword term="Values:PI" />
                <MadCap:keyword term="PI" />pi() - value of PI (e.g. 3.14159...)</li>
            <li>pow( x, y ) - 'x' to the power of 'y'.</li>
            <li>
                <MadCap:keyword term="Sqrt" />sqrt( x ) - square root of 'x'.</li>
            <li>exp( x ) - e to the power of 'x', where e is the 
 base of the natural logarithms.</li>
            <li>log( x ) - natural logarithm of 'x'.</li>
            <li>log( x, y ) - logarithm of 'x' to base 'y', e.g. 
 log( 100, 10) = 2</li>
            <li>time() - Time in seconds since 1 January 1970 UTC.</li>
        </ul>
        <h2>
            <MadCap:keyword term="Built-in String Functions" />Built-in String Functions</h2>
        <ul>
            <li><a href="#defined">defined<MadCap:xref href="#defined" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>(str) - Takes a string argument, and returns a non-zero value (1) if the variable name specified in the input string is defined.</li>
            <li><a href="#strfind">strfind<MadCap:xref href="#strfind" target="" title="" alt=""> (Pg 1)</MadCap:xref></a>( strToBeSearched STRING, substrToFind STRING ) - Case sensitive match returns the position of the first matching substring.</li>
            <li><a href="#strifind">strifind<MadCap:xref href="#strifind" target="" title="" alt=""> (Pg 1)</MadCap:xref> <![CDATA[ ]]></a>( strToBeSearched STRING, substrToFind STRING ) - Case insensitive match returns the position of the first matching substring.</li>
            <li>
                <MadCap:keyword term="Len" />
                <MadCap:keyword term="Strlen" /><a href="#strlen">strlen<MadCap:xref href="#strlen" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>(str) - Returns the length in bytes of the string 'str'  or the combined length of all string arguments.</li>
            <li>
                <MadCap:keyword term="Fmt" />
                <MadCap:keyword term="Sprintf" /><a href="#sprintf">sprintf<MadCap:xref href="#sprintf" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>( fmt, ...) - Returns formatted string using format specifier 'fmt'. Format specifier 'fmt' contains format codes that begin with '%'.</li>
            <li>
                <MadCap:keyword term="Secs" />
                <MadCap:keyword term="Strftime" /><a href="#strftime">strftime<MadCap:xref href="#strftime" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>( fmt, [secs]) - Returns formatted date/time string using format specifier 'fmt'.</li>
            <li>
                <MadCap:keyword term="Strptime" /><a href="#strptime">strptime<MadCap:xref href="#strptime" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>( str, fmt ) - Returns the number of seconds since UTC 1970 represented by the given date/time string, as interpreted using the specified format code.</li>
            <li><a href="#subid">subid<MadCap:xref href="#subid" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>(oid, start, length) - Gets the specified length sub-OIDs from a given OID string, starting from index start (the index starts from 0). </li>
            <li><a href="probecalculations.htm#substr"><MadCap:keyword term="Substr" />substr<MadCap:xref href="probecalculations.htm#substr" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>( 
 str, offset, len )</li>
            <li><a href="probecalculations.htm#unpack">unpack<MadCap:xref href="probecalculations.htm#unpack" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>( 
 binary str, fmt )</li>
            <li>Regular Expressions - See below for <a href="#regexp">an example that uses Regular Expressions<MadCap:xref href="#regexp" target="" title="" alt="" MadCap:conditions="Primary.print" /></a>.</li>
        </ul>
        <h2 class="pagebreakbefore">
            <MadCap:keyword term="Function Descriptions" />Function Descriptions</h2>
        <h3><a name="defined"></a>defined</h3>
        <p>FUNCTION defined(variable:STRING):INTEGER;</p>
        <p>Returns a non-zero value (1) if the variable name specified in the input string is defined (it has already been assigned a value).
</p>
        <p><b>Note:</b> This function takes a string argument. Note the usage below.</p>
        <p>Example:
</p><pre class="code">&#160;&#160;&#160;defined("var2") == 1 ? "$var2 is defined" : "$var2 is undefined"
</pre>
        <h3><a name="round"></a>round</h3>
        <p>FUNCTION round(x:DOUBLE, y:INTEGER):DOUBLE;
</p>
        <p>FUNCTION round(x:DOUBLE):INTEGER;
</p>
        <p>Rounds a given double value (<b style="font-style: italic;">x</b>) to the nearest integer or to the given number of decimal places (<b style="font-style: italic;">y</b>).</p>
        <p>Examples: 
   </p><pre class="code">round(8.6) --&gt; 9
round(3.14159, 3) = 3.142
</pre>
        <h3><a name="strfind"></a>strfind</h3>
        <p>FUNCTION&#160;strfind( strToBeSearched:STRING, substrToFind:STRING ):INTEGER  </p>
        <p>Case-sensitive string match returns an integer representing the position of the first occurrence of a substring in the string. If the substring is not found, the function returns a value of -1.</p>
        <p>Example:</p><pre class="code">strfind( "Ethernet Interface", "int") <br /><br /> returns -1 (did not find the substring)</pre>
        <h3><a name="strifind"></a>strifind</h3>
        <p>FUNCTION strifind( strToBeSearched:STRING, substrToFind:STRING ): INTEGER</p>
        <p>Case-insensitive string match returns an integer representing the position of the first occurrence of a substring in the string. If the substring is not found, the function returns a value of -1.</p>
        <p class="pagebreakbefore">Example:</p><pre class="code">strifind( "Ethernet Interface", "int") <br /><br /> returns 9 (found the substring at position 9)</pre>
        <h3><a name="strlen"></a>strlen</h3>
        <p>FUNCTION&#160;strlen(str[, ...]:STRING):INTEGER</p>
        <p>Returns the length of the string <b style="font-style: italic;">str</b> in bytes.
<br />Returns the combined length of all string arguments in bytes.
</p>
        <p>Examples:
	
	</p><pre class="code">strlen( "Help/Systems" ) &#160;--&gt;  8
strlen( "Help/Systems", "2000" )&#160;--&gt;&#160;&#160;12</pre>
        <h3><a name="sprintf"></a>sprintf</h3>
        <p>FUNCTION&#160;sprintf( fmt:STRING, ... ):STRING</p>
        <p>Returns formatted string using format specifier <b style="font-style: italic;">fmt</b>. Format specifier <b style="font-style: italic;">fmt</b> contains format codes that begin with '%'. The following format codes are supported:</p>
        <ul>
            <li>c	- Formats numeric argument as ascii character
	</li>
            <li>d	- 	Formats numeric argument as decimal integer
</li>
            <li>	o	- 	Formats numeric argument as octal integer
	</li>
            <li>x	- 	Formats numeric argument as hexadecimal number (lower case)
	</li>
            <li>X	- 	Formats numeric argument as hexadcimal number (upper case)
</li>
            <li>	u	- 	Formats numeric argument as decimal integer (unsigned)
	</li>
            <li>s	- 	Formats argument as an ascii string (NUL terminated)
	</li>
            <li>a	- 	Formats argument as a hexadecimal string with bytes separated by ':'</li>
            <li>f	- 	Formats numeric argument as floating point (fixed precision)
</li>
            <li>	e	- 	Formats numeric argument as floating point (scientific notation)
</li>
            <li>	g	- 	Formats numeric argument as floating point (easy to read)
	</li>
            <li>%	- 	Prints a percent sign</li>
        </ul>
        <p>The general specification for a format code is:

	</p><pre class="code">% [-] [&lt;width&gt;] [. &lt;precision&gt; ] &lt;code&gt;</pre>
        <h4 class="pagebreakbefore">String Formatting
</h4>
        <p>For string data using %s, the width specifies the minimum width of the output field, and the precision specifies the number of characters to output. If the number of output characters is less than the minimum field width, the output is padded with spaces. </p>
        <p>Example:
</p><pre class="code">sprintf( "%10s", "Help/Systems" )
  &#160;Results in "&#160;&#160; Help/Systems"
sprintf( "%s", "Help/Systems" )<br />&#160;&#160;&#160;Results in "Help/Systems"
</pre>
        <p>The default alignment is to the right; so padding is added to the beginning of the string. To left align the output of %s, you need to include a '-' immediately following the '%':
</p><pre class="code">sprintf( "%-10s", "Help/Systems" )<br />&#160;&#160;&#160;Results in "Help/Systems&#160;&#160;"
sprintf( "%-10.4s", "Help/Systems" )<br />&#160;&#160;&#160;Results in "Dart&#160;&#160;&#160;&#160;&#160;"
</pre>
        <h4>Integer Formatting</h4>
        <p>Integers format similar to strings, except the &lt;precision&gt; field specifies the maximum field width, and this is enforced by padding with 0's if necessary.</p><pre class="code">sprintf( "%5d", 12 )<br />&#160;&#160;&#160;Results in "&#160;&#160;&#160;12"
sprintf( "%-5d", 12 )<br />&#160;&#160;&#160;Results in "12&#160;&#160;&#160;"
sprintf( "%6.5d", 12 )
&#160;&#160;&#160;Results in "&#160;00012"
sprintf( "%-2X", 15 )<br />&#160;&#160;&#160;Results in "F&#160;"
sprintf( "%-2.2x", 15 )<br />&#160;&#160;&#160;Results in "0f"
</pre>
        <h4 class="pagebreakbefore">Floating Point Formatting

</h4>
        <p>The floating point format codes use the &lt;precision&gt; field to specify the number of decimal places following the decimal point. %f uses the format '[-]ddd.ddd', and %e uses the format '[-]d.ddde+-dd'.
</p><pre class="code">sprintf( "%f", 1/2 )
&#160;&#160;&#160;Results in "0.500000"
sprintf( "%5.3f", 1/2 )
&#160;&#160;&#160;Results in "0.500"
sprintf( "%e", 1/2 )
&#160;&#160;&#160;Results in "5.000000e-01"
sprintf( "%g", 1/2 )
&#160;&#160;&#160;Results in "0.5"</pre>
        <h4>Address Formatting</h4>
        <p>The %a format code outputs a string in hexadecimal.</p><pre class="code">sprintf( "%a", "\x01\x02\x03" )<br />&#160;&#160;&#160;Results in "01:02:03"
sprintf( "%a", "Help/Systems" )<br />&#160;&#160;&#160;Results in "44:61:72:74:77:61:72:65"
</pre>
        <h3 class="pagebreakbefore"><a name="strftime"></a>strftime</h3>
        <p>FUNCTION&#160;strftime( fmt [, time] )</p>
        <p>Returns formatted date/time string using format specifier 'fmt'. Format specifier 'fmt' contains format codes that begin with '%'. If a time argument is provided, it must be in seconds since UTC 1970. If no time argument is provided, it defaults to the current time. The following format codes are supported on all platforms:</p>
        <ul>
            <li>	a	- 	Abbreviated weekday name
</li>
            <li>	A	- 	Full weekday name
	</li>
            <li>b	- 	Abbreviated month name
</li>
            <li>	B	- 	Full month name
</li>
            <li>	c	- 	Date and time formatted something like "Tue Feb 06 10:25:22 2007"
	</li>
            <li>d		- Day of month (01-31)
	</li>
            <li>H	- 	Hour number (00-23)
</li>
            <li>	I	- 	Hour number (01-12)
</li>
            <li>j	- 	Day of the year number (001-366)
</li>
            <li>	m	- 	Month number (01-12)
</li>
            <li>	M	- 	Minute number (00-59)
</li>
            <li>	p	- 	"AM" or "PM"
</li>
            <li>	S	- 	Second number (00-61)
</li>
            <li>s - returns the number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</li>
            <li>U	- 	Week of the year number (00-53). First Sunday is day 1 of week 1.
	</li>
            <li>w	- 	Weekday number (0-6). Sunday is 0.
	</li>
            <li>W	- 	Week of the year number (00-53). First Monday is day 1 or week 1.
</li>
            <li>	x	- 	Date.
</li>
            <li>	X	- 	Time.
</li>
            <li>	y	- 	Two-digit year number (00-99)
	</li>
            <li>Y	- 	Year with century (e.g. 2007)
	</li>
            <li>z	- returns the +hhmm or -hhmm numeric timezone (that is, the hour and minute offset from UTC) for the InterMapper server.
	</li>
            <li>%	- 	Prints a percent sign
</li>
        </ul>
        <p>The strftime function is implemented using the identically named function in the underlying system. Other format codes may work, but these are not portable.</p><pre class="code">strftime( "%c")
&#160;&#160;&#160;Results in "Tue Feb  6 11:19:24 2007"
strftime( "%Y-%m-%d", 1170778895)
&#160;&#160;&#160;Results in "2007-02-06"
</pre>
        <h3><a name="strptime"></a>strptime</h3>
        <p>FUNCTION&#160;strptime( str , fmt )
</p>
        <p>Returns the number of seconds since UTC 1970 represented by the given date/time string, as interpreted using the specified format code. Basically, this function can be used to parse dates.

</p>
        <p>This function uses the same underlying format codes as strftime.

</p>
        <p class="pagebreakbefore">Example:
</p><pre class="code">strftime( "%Y", strptime( "1990", "%Y"))
&#160;&#160;&#160;Results in "1990"</pre>
        <h3><a name="subid"></a>subid&#160;</h3>
        <p>FUNCTION&#160;subid(oid, start, length)</p>
        <p> Gets the specified length sub-OIDs from a given OID string, starting from index start (the index starts from 0). When the start index is negative, it will be counted from the end of the OID string.</p>
        <p>Examples:</p><pre class="code">subid("1.3.6.1.2.1.4.20.1.1.10.10.2.20", 0, 2) &#160;&#160;&#160;--&gt; "1.3"
subid("1.3.6.1.2.1.4.20.1.1.10.10.2.20", -4, 4) &#160;&#160;--&gt; "10.10.2.20"
subid(\"1.3.6.1.2.1.4.20.1.1.10.10.2.20\", 0, 2) &#160;--&gt; \"1.3\"
subid(\"1.3.6.1.2.1.4.20.1.1.10.10.2.20\", -4, 4) --&gt; \"10.10.2.20\"
subid(\"1.3.6.1.2.1.4.20.1.1.10.10.2.20\", 4, 4) &#160;--&gt; \"2.1.4.20\"
subid(\"1.3.6.1.2.1.4.20.1.1.10.10.2.20\", -2, 4) --&gt; \"2.20\"
subid(\"1.3.6\", 3, 4) &#160;--&gt; \"\"
subid(\"1.3.6\", 2, 4) &#160;--&gt; \"6\"
subid(\"1.3.6\", -4, 4) --&gt; \"1.3.6\"
subid(\"1.3.6\", -2, 4) --&gt; \"3.6\"
</pre>
        <h3><a name="substr"></a>substr</h3>
        <p>FUNCTION 
 substr(<span style="font-style: italic;">str</span>:STRING,                                       <span style="font-style: italic;">offset</span>:INTEGER):STRING;<br /><MadCap:keyword term="FUNCTION substr" />FUNCTION substr(<span style="font-style: italic;">str</span>:STRING,                                       <span style="font-style: italic;">offset</span>:INTEGER,                                       <span style="font-style: italic;">length</span>:INTEGER):STRING;</p>
        <p>&#160;
            <MadCap:keyword term="Substring" /><MadCap:keyword term="Substring:Extract" /><MadCap:keyword term="Extract" /><MadCap:keyword term="Extract:substring" />Extract 
 a substring out of <b style="font-style: italic;">str </b>and return it. The substring is extracted starting 
 at <b style="font-style: italic;">offset </b>characters from the start of the string. </p>
        <ul style="list-style: disc;" type="disc">
            <li>If <b style="font-style: italic;">offset </b>is negative, the substring starts that 
 far from the end of the string instead; <b style="font-style: italic;">length </b>indicates the length of 
 the substring to extract. </li>
            <li>If <b style="font-style: italic;">length </b>is omitted, everything from <b style="font-style: italic;">offset</b> to the end of the 
 string is returned. </li>
            <li>If <b style="font-style: italic;">length </b>is negative, the length is calculated to 
 leave that many characters off the end of the string. If neither <b style="font-style: italic;">offset </b>nor <b style="font-style: italic;">length </b>is supplied, the function will return <b style="font-style: italic;">str</b>. (See Perl <i>substr</i>).</li>
        </ul>
        <p>Examples:</p><pre class="code">substr( "0123456789", 7) &#160;&#160;&#160;&#160;--&gt;&#160;&#160;&#160;"789"<br />substr( "0123456789", 4, 2) &#160;--&gt; &#160;&#160;"45"<br />substr( "0123456789", 4, -2) --&gt; &#160;&#160;"4567"<br />substr( "0123456789", -2, 1) --&gt; &#160;&#160;"8"</pre>
        <h3 class="pagebreakbefore"><a name="unpack"></a>unpack</h3>
        <p>&#160;FUNCTION 
 unpack(<span style="font-style: italic;">str</span>:STRING,                                       <span style="font-style: italic;">format</span>:STRING):VALUE</p>
        <p>Take a string <b style="font-style: italic;">str</b> representing a data value and convert it into a scalar 
 value. The format string specifies the type of value to be unpacked. (See 
 perl <i>unpack</i>).</p>
        <ul style="list-style: disc;" type="disc">
            <li>If the input string is shorter than the expected 
 number of bytes to be unpacked, treat the input string as if it is padded 
 with zero bytes at the end. <br /><br /><span class="code">  unpack("\1\2\3",  "&gt;L") </span><br /><br />is the same as <br /><br /><span class="code">  unpack("\1\2\3\0",  "&gt;L")</span><br /><br /></li>
            <li>If the input string is longer, the remaining bytes 
 in the input are ignored. </li>
            <li>
                <MadCap:keyword term="Endian" />If the endian modifier is not supplied, we will use 
 the target platform's byte order (little endian on Windows, big endian on Mac). </li>
            <li>If format specifier is not supplied, the function 
 will return <span style="font-style: italic;">str</span>.</li>
        </ul>
        <br />
        <style>
			#formats td p.code {width: 40px;margin: 0;}
			#formats td p.td {margin:0;padding:0;}
			#formats td {height: auto;padding: 5px;}
		</style>
        <table id="formats" style="border-spacing: 0;width: 80%;margin-left: 24px;" width="80%" cellspacing="0">
            <col style="width: 60px;" />
            <col style="width: auto;" />
            <tr valign="top">
                <td>
                    <p style="font-weight: bold;">Format specifier</p>
                </td>
                <td>
                    <p style="font-weight: bold;">Description</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">c</span> <![CDATA[ ]]></p>
                </td>
                <td>
                    <p class="td">signed character value (1 byte)</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">C</span> <![CDATA[ ]]></p>
                </td>
                <td>
                    <p class="td">unsigned character value (1 byte)</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">l</span> <![CDATA[ ]]></p>
                </td>
                <td>
                    <p class="td">signed long value (4 bytes)</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">L</span> <![CDATA[ ]]></p>
                </td>
                <td class="p">
                    <p class="td">unsigned long value (4 bytes)</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">s</span> <![CDATA[ ]]></p>
                </td>
                <td class="p">
                    <p class="td">signed short value (2 bytes)</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">S</span> <![CDATA[ ]]></p>
                </td>
                <td class="p">
                    <p class="td">unsigned short value (2 bytes)</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">#B</span> <![CDATA[ ]]></p>
                </td>
                <td class="p">
                    <p class="td">
                        <MadCap:keyword term="Base64" />a base64 string (all bytes) </p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">&gt;</span> <![CDATA[ ]]></p>
                </td>
                <td class="p">
                    <p class="td">
                        <MadCap:keyword term="Big-endian" />big-endian modifier</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">&lt;</span> <![CDATA[ ]]></p>
                </td>
                <td class="p">
                    <p class="td">
                        <MadCap:keyword term="Little-endian" />little-endian modifier</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;">
                    <p><span class="code">H</span> <![CDATA[ ]]></p>
                </td>
                <td>
                    <p class="td">decodes the given hexadecimal value and returns an integer (up to 32-bits)</p>
                </td>
            </tr>
            <tr valign="top">
                <td style="vertical-align: top;"><span class="code">#H</span> <![CDATA[ ]]></td>
                <td>
                    <p class="td">decodes the given hexadecimal value and returns a string</p>
                </td>
            </tr>
        </table>
        <p>Examples:</p><pre class="code" xml:space="preserve">unpack( "\1", "c") &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;  1
unpack( "\1\2\3\4", "&gt;L") &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt; &#160;16909060
unpack(  "\1\2\3\4", "&lt;L") &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;  67305985
unpack(  "BS64", "#B") &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt; &#160;"..."  (where "..." is "\x5\x2e\xb8")
unpack(  "\1\2\3", "&gt;L") &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;  16909056
unpack( "1F", "H")  &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt; &#160;31
unpack( "42696c6c207761732068657265", "#H") --&gt; &#160;"Bill was here"</pre>
        <p><span style="font-weight: bold;">Note:</span> The unpack() function supports one format code in the format string.</p>
        <p><a name="regexp"></a>
        </p>
        <h2>Using Regular Expressions In Custom SNMP Probes</h2>
        <p>You can use a regular expression to divide a string into separate variables after retrieving it from a device.&#160;In the example below, a customer had a piece of equipment that returned the following information in sysDescr.0:</p><pre class="code">FW TR6-3.1.4Rt_F213E4, 2.4GHz, 0dBi ext. antenna        </pre>
        <p>They created a probe that retrieved sysDescr.0 and then parsed out those strings with the following commands in the &lt;snmp-device-variables&gt; section of the probe:</p><pre class="code">
&lt;snmp-device-variables&gt;<br />&#160;&#160;sysDescr, &#160;1.3.6.1.2.1.1.1.0,                                          DEFAULT,     "system description"
&#160;&#160;firmware, &#160;"$sysDescr" =~ "^FW ([^,]+), (.+)Hz, (.+) antenna" ;"${1}", CALCULATION, "Firmware"
&#160;&#160;frequency, "${2}",                                                     CALCULATION, "Frequency"
&#160;&#160;antenna,  "${3}",                                                     CALCULATION, "Antenna"
. . .<br />&lt;/snmp-device-variables&gt;</pre>
        <ol>
            <li> Retrieve sysDescr.0 (OID of 1.3.6.1.2.1.1.1.0) and assign it to the variable $sysDescr.</li>
            <li>Set the value of $firmware based on the calculation. There are many things going on in this line:
<ul><li>The "=~" operator indicates that the $sysDescr variable should be parsed using the regular expression string that follows.</li><li>This regular expression breaks the string at the comma characters. The "[^,]" matches any single character that isn't a comma; adding a "+" forms a pattern that matches multiple non-comma characters.</li><li>Parentheses around a pattern serve to memorize a string. Each pair of paren's matches a string whose value is placed in variables numbered ${1}, ${2}, ${3}, etc.</li><li>The semicolon followed by "${1}" indicates that the entire CALCULATION should return the value of ${1} as a string.</li><li> The variable $firmware thus gets assigned the value of ${1}<br /><br /></li></ul></li>
            <li>Assign the variable $frequency with the result of the second match (${2}).</li>
            <li>Assign the variable $antenna with the result of the third match (${3}).</li>
        </ol>
        <p><b>Note: </b>It is beyond the scope of this manual to describe the full capabilities of
regular expressions. There are a number of tutorials available on the web. One 
example is the <a href="http://perldoc.perl.org/perlretut.html">Perl Regular
Expression Tutorial</a>.</p>
    </body>
</html>